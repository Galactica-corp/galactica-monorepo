import { MerkleProof, ZkCertData, ZkCertRegistered } from '@galactica-net/galactica-types';

export type {
  ProviderData,
  MerkleProof,
  ZkCertData,
  ZkCertRegistered,
} from '@galactica-net/galactica-types';
export { ZkCertStandard } from '@galactica-net/galactica-types';

/**
 * Data defining a zk circuit prover
 */
export type ProverData = {
  // Prover code in web assembly that will be used to generate the proof in the Snap.
  wasm: any;
  // Corresponding parameters from the zkey file (SNARK trusted setup ceremony). The binary fields are base64 encoded.
  zkeyHeader: any;
  // Array of base64 encoded zkey sections used by snarkjs. The binary fields are base64 encoded.
  zkeySections: any[];
};

/**
 * ZkCert proof as it is generated by the snap.
 */
export type ZkCertProof = {
  proof: {
    // disable eslint naming convention rule for this because it is the name given by snarkjs
    /* eslint-disable @typescript-eslint/naming-convention */
    pi_a: [string, string];
    pi_b: [[string, string], [string, string]];
    pi_c: [string, string];
    /* eslint-enable @typescript-eslint/naming-convention */
    protocol: string;
    curve: string;
  };
  publicSignals: string[];
};

/**
 * Parameters for zkCert selection.
 * Because the website does not know IDs for zkCerts, it can provide an optional list of filters to simplify selecting the zkCert.
 */
export type ZkCertSelectionParams = {
  zkCertStandard?: string;
  expirationDate?: number;
  providerAx?: string;
};

export interface EncryptedZkCert extends EthEncryptedData {
  // holder commitment to associate the zkCert with the holder who can decrypt it
  holderCommitment: string;
}

/**
 * Encrypted data type consistent with the EthEncryptedData type from eth-sig-util.
 * We use it to encrypt zkCerts.
 */
export declare type EthEncryptedData = {
  version: string;
  nonce: string;
  ephemPublicKey: string;
  ciphertext: string;
};
